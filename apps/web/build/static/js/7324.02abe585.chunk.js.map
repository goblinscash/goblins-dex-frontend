{"version":3,"file":"static/js/7324.02abe585.chunk.js","mappings":"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","sources":["helpers/utils.js","utils/web3Intraction.js"],"sourcesContent":["import { toast } from \"react-toastify\";\nimport { ethers } from \"ethers\";\nimport BigNumber from \"bignumber.js\";\n\nconst PRECISION = 4;\n\nexport function truncateWalletAddress(address, isNotWalletAddress) {\n  if (!address) return \"\";\n  if (!isNotWalletAddress) {\n    address = address.slice(0, 7) + \"...\" + address.slice(36);\n  } else {\n    address = address.slice(0, 8) + \"...\" + address.slice(55);\n  }\n\n  return address;\n}\n\nexport const copyClipBoard = (value) => {\n  if (!value) return toast.error(\"Something wrong!\");\n\n  let textarea = document.createElement(\"textarea\");\n  textarea.textContent = value;\n  textarea.style.position = \"fixed\"; // Prevent scrolling to bottom of page in Microsoft Edge.\n  document.body.appendChild(textarea);\n  textarea.select();\n  try {\n    document.execCommand(\"copy\"); // Security exception may be thrown by some browsers.\n  } catch (ex) {\n    console.warn(\"Copy to clipboard failed.\", ex);\n    // return prompt(\"Copy to clipboard: Ctrl+C, Enter\", text);\n  } finally {\n    document.body.removeChild(textarea);\n  }\n\n  toast.success(\"Copied!\");\n};\n\nexport const getCheckSumAddress = (address) => {\n  if (!address) return null;\n  try {\n    return ethers.utils.getAddress(address);\n  } catch (error) {\n    return null;\n  }\n};\n\nexport function validateTelegramLink(link) {\n  // Define a regular expression for a Telegram link\n  const telegramRegex = /^(https?:\\/\\/)?(www\\.)?t\\.me\\/[a-zA-Z0-9_]{5,32}\\/?$/;\n\n  // Test the link against the regular expression\n  const isValid = telegramRegex.test(link);\n\n  // Return the validation result\n  return isValid;\n}\n\nexport function isValidEmail(email) {\n  // Regular expression for basic email validation\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n  // Test the email against the regular expression\n  return emailRegex.test(email);\n}\n\nexport function getPercentage(partialValue, totalValue) {\n  return (100 * partialValue) / totalValue;\n}\n\nexport function getGrowthPercentage(initialValue, currentValue) {\n  initialValue = Number(initialValue);\n  currentValue = Number(currentValue);\n  return ((currentValue - initialValue) / initialValue) * 100;\n}\n\nexport const sumArrayValue = (arr, key) => {\n  const result = arr.reduce(function (acc, obj) {\n    return Number(acc) + Number(obj[key]);\n  }, 0);\n  return result || 0;\n};\n\nexport function formatValue(value) {\n  if (!value) return 0;\n  value = Number(value);\n  if (value < 1000) {\n    return Number(value).toFixed(0);\n  }\n  if (value >= 1000 && value < 100000) {\n    return ` ${(value / 1000).toFixed(0)}K`;\n  } else if (value >= 100000 && value < 1000000) {\n    return ` ${(value / 1000).toFixed(0)}K`;\n  } else if (value >= 1000000 && value <= 1000000000) {\n    return ` ${(value / 1000000).toFixed(0)}M`;\n  } else if (value >= 1000000000 && value < 1000000000000) {\n    return ` ${(value / 1000000000).toFixed(0)}B`;\n  } else {\n    return Number(value).toFixed(0);\n  }\n}\n\nexport function hexStringToNumber(hexString) {\n  return parseInt(hexString, 16);\n}\n\nexport const calculateBonus = (amount) => {\n  amount = Number(amount);\n  if (amount >= 100 && amount < 500) {\n    return 1; // 1%bonus\n  } else if (amount >= 500 && amount < 2000) {\n    return 2; //2% bonus\n  } else if (amount >= 2000 && amount < 10000) {\n    return 3; //3% bonus\n  } else if (amount >= 10000 && amount < 20000) {\n    return 5; //5% bonus\n  } else if (amount >= 20000) {\n    return 10; //10% bonus\n  } else {\n    return 0;\n  }\n};\n\nexport const convertWeiToEth = (value) => {\n  if (!value) return 0;\n\n  value = value.toString();\n\n  return Number(ethers.utils.formatEther(value));\n};\n\nexport function toFixed(a, b, precision) {\n  if (toBigNumber(a).isZero() || toBigNumber(b).isZero()) {\n    return \"0\";\n  }\n  return toBigNumber(a)\n    .div(toBigNumber(b))\n    .toFormat(precision ?? PRECISION);\n}\n\nexport function formatUnits(a, decimals, precision) {\n  if (!decimals) return \"\";\n  return toFixed(a, toBigNumber(10).pow(decimals), precision);\n}\n\nexport function toBigNumber(n) {\n  return new BigNumber(n.toString());\n}\n\nexport function toFixedCustm(x) {\n  if (Math.abs(x) < 1.0) {\n    var e = parseInt(x.toString().split(\"e-\")[1]);\n    if (e) {\n      x *= Math.pow(10, e - 1);\n      x = \"0.\" + new Array(e).join(\"0\") + x.toString().substring(2);\n    }\n  } else {\n    var e = parseInt(x.toString().split(\"+\")[1]);\n    if (e > 20) {\n      e -= 20;\n      x /= Math.pow(10, e);\n      x += new Array(e + 1).join(\"0\");\n    }\n  }\n  return x;\n}\nexport function truncateToFixed(value, decimalPlaces) {\n  const factor = Math.pow(10, decimalPlaces);\n  return Math.floor(value * factor) / factor;\n}\n\n\n\nexport const makeByteData = (data) => {\n\n  const incentiveKeyAbi =\n    \"tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)\";\n    let byteData = ethers.utils.defaultAbiCoder.encode([incentiveKeyAbi], [data])\n    return byteData\n};\n\n\nexport const makeByteDataForV3 = (data) => {\n\n  const incentiveKeyAbi =\n    \"tuple(uint256 whatToDo,address targetToken,uint256 amountRemoveMin0,uint256 amountRemoveMin1,uint256 amountIn0,uint256 amountOut0Min,bytes swapData0, uint256 amountIn1,uint256 amountOut1Min,bytes swapData1,uint128 feeAmount0,uint128 feeAmount1,uint24 fee,int24 tickLower,int24 tickUpper,uint128 liquidity,uint256 amountAddMin0,uint256 amountAddMin1,uint256 deadline,address recipient,address recipientNFT,bool unwrap,bytes returnData,bytes swapAndMintReturnData)\";\n    let byteData = ethers.utils.defaultAbiCoder.encode([incentiveKeyAbi], [data])\n    return byteData\n};\n\n\nexport function toCommas(value) {\n  let parts = value.toString().split(\".\");\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  return parts.join(\".\");\n}\n","import { Contract, ethers } from \"ethers\";\n\n//ABI\nimport MigrationStakingABI from \"./ABI/migrationStaking.json\";\nimport NFTManager from \"./ABI/NonfungiblePositionManager.json\";\nimport PancakeV3Pool from \"./ABI/PancakeV3Pool.json\";\nimport StakeABI from \"./ABI/StakeABI.json\";\nimport TokenABI from \"./ABI/TokenABI.json\";\nimport UniswapV3Factory from \"./ABI/UniswapV3Factory.json\";\nimport UniswapV3Staker from \"./ABI/UniswapV3Staker.json\";\n\nimport { makeByteData, makeByteDataForV3, toFixedCustm } from \"../helpers/utils\";\n\nclass Web3Intraction {\n  constructor(currentNetwork, provider) {\n    if (provider || window.ethereum) {\n      this.PROVIDER = provider;\n      this.PROVIDER = provider;\n      this.SIGNER = this.PROVIDER.getSigner();\n    } else if (currentNetwork) {\n      this.PROVIDER = new ethers.providers.JsonRpcProvider(\n        currentNetwork?.rpcUrl\n      );\n      this.SIGNER = this.PROVIDER;\n    }\n    this.contractDetails = {\n      abi: UniswapV3Staker,\n      ...currentNetwork,\n    };\n    this.walletType = currentNetwork.label;\n    this.chainId = currentNetwork.chainId;\n  }\n\n  /**\n   * Get contract from abi and address\n   *\n   * @param {string} abi - ABI JSON\n   * @param {string} address - Contract Address\n   * @param {boolean} isSigner - signer ot not\n   *\n   * @returns {object} Contract\n   */\n\n  getContract = (abi, address, isSigner) => {\n    try {\n      let contract = new Contract(\n        address,\n        JSON.parse(abi),\n        isSigner ? this.SIGNER : this.PROVIDER\n      );\n\n      return contract;\n    } catch (error) {\n      console.log(\"error\", error);\n      return null;\n    }\n  };\n\n  contractInstance = (abi, address, _provider) => {\n    try {\n      let contract = new Contract(\n        address,\n        JSON.parse(abi),\n        new ethers.providers.JsonRpcProvider(_provider)\n      );\n\n      // let contract = new ethers.Contract(address, abi, new ethers.providers.JsonRpcProvider(_provider));\n\n      return contract;\n    } catch (error) {\n      console.log(\"error\", error);\n      return null;\n    }\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAmount number token amount\n   * @param {Number} tokenAddress token address\n\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  checkAllowance = async (tokenAmount, tokenAddress, approvalAddress) => {\n    return new Promise(async (resolve, reject) => {\n      let tokenAmountWithDecimal = 0;\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n        if (tokenAddress && approvalAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let getBalance = await tokenContract.balanceOf(walletAddres);\n          let tokenDecimal = await tokenContract.decimals();\n\n          getBalance = getBalance.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getBalance)) {\n            return reject(\"Don't have enough token\");\n          }\n\n          let tokenAllowence = await tokenContract.allowance(\n            walletAddres,\n            approvalAddress\n          );\n\n          let getTotalSupply = await tokenContract.totalSupply();\n          let getTotalSupplyInEth =\n            getTotalSupply.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getTotalSupplyInEth)) {\n            return reject(\"Don't have enough supply in pool\");\n          }\n\n          // tokenAmount = parseInt(tokenAmount);\n          tokenAllowence = tokenAllowence.toString();\n\n          if (tokenDecimal == 18) {\n            tokenAmountWithDecimal = ethers.utils.parseUnits(\n              tokenAmount.toString(),\n              \"ether\"\n            );\n          } else {\n            tokenAmountWithDecimal = Number(tokenAmount) * 10 ** tokenDecimal;\n          }\n          tokenAmountWithDecimal = toFixedCustm(parseInt(tokenAmountWithDecimal));\n\n          if (Number(tokenAmountWithDecimal) > tokenAllowence) {\n            const txn = await tokenContract.approve(\n              approvalAddress,\n              tokenAmountWithDecimal.toString()\n            );\n            await txn.wait();\n          }\n          setTimeout(() => {\n            resolve(tokenAmountWithDecimal);\n          }, 5000)\n        }\n      } catch (error) {\n        if (error?.code === -32000) {\n          setTimeout(() => {\n            resolve(tokenAmountWithDecimal);\n          }, 5000)\n          return\n        }\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Create Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {number} rewards reward amount\n   * @param {number} minimumWidth Minimum Width value\n   * @param {address} tokenAddress Reward token address\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  createIncentive = async (keys, rewards, minimumWidth, tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx;\n        if (!tokenAddress) {\n          return reject(\"Token Address not found!\");\n        }\n        let rewardTokenAmount = await this.checkAllowance(\n          rewards,\n          tokenAddress,\n          this.contractDetails?.contractAddress\n        );\n\n        tx = await contract.createIncentive(\n          keys,\n          rewardTokenAmount.toString(),\n          minimumWidth\n        );\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in createIncentive\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * NFT Stake in Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  stake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getByteData = makeByteData(keys);\n        let getSafeContract = await this.getContract(\n          JSON.stringify([\n            {\n              inputs: [\n                {\n                  internalType: \"address\",\n                  name: \"from\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"address\",\n                  name: \"to\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"uint256\",\n                  name: \"tokenId\",\n                  type: \"uint256\",\n                },\n                {\n                  internalType: \"bytes\",\n                  name: \"_data\",\n                  type: \"bytes\",\n                },\n              ],\n              name: \"safeTransferFrom\",\n              outputs: [],\n              stateMutability: \"nonpayable\",\n              type: \"function\",\n            },\n          ]),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getOwner = await contract.ownerOf(tokenId);\n        if (getOwner !== walletAddress) {\n          reject(\"You are not a NFT owner!\");\n          return;\n        }\n\n\n        // Encode the function calls\n        const approve = await contract.interface.encodeFunctionData(\"approve\", [\n          this.contractDetails.contractAddress,\n          tokenId,\n        ]);\n        const safeTransferFrom =\n          await getSafeContract.interface.encodeFunctionData(\n            \"safeTransferFrom\",\n            [\n              walletAddress,\n              this.contractDetails.contractAddress,\n              tokenId,\n              getByteData,\n            ]\n          );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[approve, safeTransferFrom]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.nftManagerContractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for unstake and claim\n   * @param {array} keys [[reward token, pool address,start time, endTime, refundee address]]\n   * @param {string} tokenId token id\n   * @param {string} walletAddress Wallet Address\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  multiStakeWithMultiCall = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let stakeData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          let stakeToken = await contract.interface.encodeFunctionData(\n            \"stakeToken\",\n            [keys[i], tokenId]\n          );\n          stakeData.push(stakeToken);\n        }\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [stakeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Deposit in Incentive\n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDeposit = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let deposit = await contract.deposits(tokenId);\n\n        resolve(deposit);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get stakes in Incentive\n   *\n   * @param {string} tokenId token id\n   * @param {string} incentiveId incentive id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getStakes = async (tokenId, incentiveId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let stakes = await contract.stakes(tokenId, incentiveId);\n\n        resolve({\n          liquidity: stakes.liquidity.toString(),\n          secondsPerLiquidityInsideInitialX128:\n            stakes.secondsPerLiquidityInsideInitialX128.toString(),\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getStakes\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewardInfo = async (keys, tokenId) => {\n    try {\n      let contract = this.getContract(\n        JSON.stringify(this.contractDetails?.abi),\n        this.contractDetails?.contractAddress,\n        true\n      );\n      let rewards = await contract.getRewardInfo(keys, tokenId);\n      return rewards;\n    } catch (error) {\n      return null;\n    }\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} rewardToken rewardToken\n   * @param {string} walletAddress token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewards = async (rewardToken, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let rewards = await contract.rewards(rewardToken, walletAddress);\n\n        resolve(rewards);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for restake\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallReStake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        // Encode the function calls\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n        const stakeToken = await contract.interface.encodeFunctionData(\n          \"stakeToken\",\n          [keys, tokenId]\n        );\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[unStakeToken, stakeToken, claimReward]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  /**\n * Mutli Call Function call for claim all  \n * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n * @param {string} tokenId token id\n *\n * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n */\n  mutliCallClaimAll = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n\n        let claimAllData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          const unStakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys[i], tokenId]\n          );\n          claimAllData.push(unStakeToken);\n\n          const stakeToken = await contract.interface.encodeFunctionData(\n            \"stakeToken\",\n            [keys[i], tokenId]\n          );\n          claimAllData.push(stakeToken);\n\n\n          const claimReward = await contract.interface.encodeFunctionData(\n            \"claimReward\",\n            [keys[i][0], walletAddress, 0]\n          );\n          claimAllData.push(claimReward);\n\n        }\n        // Encode the function calls\n\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [claimAllData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for unstake and claim\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallUnstake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let getRewards = await contract.getRewardInfo(keys, tokenId);\n        // Encode the function calls\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n        let multicallMethod = getRewards.secondsInsideX128.toString() > 0 ? [unStakeToken, claimReward] : [unStakeToken]\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [multicallMethod]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in mutliCallUnstake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  /**\n  * Mutli Call Function call for all unstake and claim \n  * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n  * @param {string} tokenId token id\n  *\n  * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n  */\n  mutliCallUnstakeAll = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n\n        let unStakeData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          const unStakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys[i], tokenId]\n          );\n          unStakeData.push(unStakeToken);\n\n\n          let getRewards = await contract.getRewardInfo(keys[i], tokenId);\n\n          if (getRewards.secondsInsideX128.toString() > 0) {\n\n            const claimReward = await contract.interface.encodeFunctionData(\n              \"claimReward\",\n              [keys[i][0], walletAddress, 0]\n            );\n            unStakeData.push(claimReward);\n          }\n\n\n\n        }\n        // Encode the function calls\n\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [unStakeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///unstake\n\n  unStake = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.unstakeToken(keys, tokenId);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  claimRewards = async (rewardsToken, walletAddress) => {\n    console.log(rewardsToken, walletAddress, \"<===data\");\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.claimReward(rewardsToken, walletAddress, 0);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///withdraw\n\n  withdrawToken = async (tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.withdrawToken(tokenId, walletAddress, \"0x\");\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token Id\n   * @param {string} walletAddress own wallet address\n   * @param {string} index index\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenId = async (walletAddress, index) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenOfOwnerByIndex(\n          walletAddress,\n          index\n        );\n\n        resolve(response.toString());\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token URI\n   * @param {string} tokenId own wallet address\n   *\n   * @returns {Promise} base64 encoded in Success or Error in Fail\n   */\n  getTokenURI = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenURI(tokenId);\n\n        // console.log(response, \"<===response\")\n\n        resolve(response);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for endIncentive and unstake all staked nft.\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {array} tokenIds [token id]\n\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  endIncentive = async (keys, tokenIds) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let encodeData = [];\n\n        for (let i = 0; i < tokenIds.length; i++) {\n          let unstakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys, tokenIds[i]]\n          );\n          encodeData.push(unstakeToken);\n        }\n\n        let endIncentive = await contract.interface.encodeFunctionData(\n          \"endIncentive\",\n          [keys]\n        );\n\n        encodeData.push(endIncentive);\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [encodeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  getTokenDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (tokenAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let tokenDecimal = await tokenContract.decimals();\n          let tokenSymbol = await tokenContract.symbol();\n\n          resolve({\n            decimal: tokenDecimal,\n            symbol: tokenSymbol,\n          });\n        }\n      } catch (error) {\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Stake\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  tokenStake = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let getStakingContract = await contract.stakingToken();\n        let stakeAmount = await this.checkAllowance(\n          amount,\n          getStakingContract,\n          this.contractDetails.stakeContractAddress\n        );\n\n        let tx = await contract.stake(stakeAmount);\n        let receipt = await tx.wait();\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Withdraw\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenWithdraw = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let getStakingContract = await contract.stakingToken();\n        let tokenData = await this.getTokenDecimal(getStakingContract);\n        let tokenAmountWithDecimal = Number(amount) * 10 ** tokenData.decimal;\n\n        tokenAmountWithDecimal = parseInt(tokenAmountWithDecimal);\n\n        let tx = await contract.withdraw(tokenAmountWithDecimal.toString());\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Exit\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenExit = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let tx = await contract.exit();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenRewards = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        let tx = await contract.getReward();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenBalance = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n        let getBalance = await tokenContract.balanceOf(walletAddres);\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n        let getTotalSupply = await tokenContract.totalSupply();\n        let getTotalSupplyInEth =\n          getTotalSupply.toString() / 10 ** tokenDecimal;\n\n        resolve({\n          balance: getBalance.toString() / 10 ** tokenDecimal,\n          tokenDecimal: tokenDecimal,\n          symbol: symbol,\n          totalSupply: getTotalSupplyInEth,\n        });\n      } catch (error) {\n        console.log(error, \"<====err in getTokenBalance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenSymbolAndDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n\n        resolve({ tokenDecimal: tokenDecimal, symbol: symbol });\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Detail info\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDetailInfo = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        let getStakingContract = await contract.stakingToken();\n\n        const bscInstance = this.contractInstance(\n          JSON.stringify(TokenABI),\n          \"0x701ACA29AE0F5d24555f1E8A6Cf007541291d110\",\n          \"https://bsc.drpc.org\"\n        )\n\n        let bscSupply = 0\n        if (this.chainId == 10000) {\n          let bscDecimal = await bscInstance.decimals()\n          bscSupply = await bscInstance.totalSupply()\n          bscSupply = bscSupply.toString() / 10 ** bscDecimal;\n        }\n\n        let walletAddress = this.SIGNER.getAddress();\n\n\n\n\n        let getRewardsContract = await contract.rewardsToken();\n        let stakeToken = await this.getTokenBalance(getStakingContract);\n\n        let rewardToken = await this.getTokenSymbolAndDecimal(\n          getRewardsContract\n        );\n\n        let stakedAmount = await contract.balanceOf(walletAddress);\n        stakedAmount = stakedAmount.toString() / 10 ** stakeToken.tokenDecimal;\n\n        let earnedAmount = await contract.earned(walletAddress);\n        earnedAmount = earnedAmount.toString() / 10 ** rewardToken.tokenDecimal;\n\n        let totalSupply = await contract.totalSupply();\n\n        totalSupply = totalSupply.toString() / 10 ** stakeToken.tokenDecimal;\n\n        let _tokenTotalSupply = parseInt(stakeToken.totalSupply - bscSupply)\n        resolve({\n          balance: parseFloat(stakedAmount) + parseFloat(stakeToken.balance),\n          stakedAmount: parseFloat(stakedAmount),\n          unStakedAmount: parseFloat(stakeToken.balance),\n          totalSupply: parseInt(totalSupply),\n          earnedAmount: earnedAmount,\n          rewardSymbol: rewardToken.symbol,\n          stakeSymbol: stakeToken.symbol,\n          tokenTotalSupply: _tokenTotalSupply,\n          unStackTotalSupply:\n            parseInt(stakeToken.totalSupply) - parseInt(totalSupply),\n        });\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  nftCount = async (id) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let res = await contract.incentives(id);\n        resolve(res);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getPoolDetails = async (poolAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(PancakeV3Pool),\n          poolAddress,\n          true\n        );\n        let getToken0Address = await contract.token0();\n        let getToken1Address = await contract.token1();\n        let getToken0Detail = await this.getTokenSymbolAndDecimal(\n          getToken0Address\n        );\n        let getToken1Detail = await this.getTokenSymbolAndDecimal(\n          getToken1Address\n        );\n        resolve({\n          token0Symbol: getToken0Detail.symbol,\n          token1Symbol: getToken1Detail.symbol,\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getPoolSymbol\");\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get APR Rewards for staking\n   *\n   * @param {Number} totalSupply total stake amount\n   * @param {Number} WBCHPrice WBCH Price in USD\n   * @param {Number} GOBPrice GOB Price in USD\n   *\n   *\n   * @returns {Promise} Number APR in Success or Error in Fail\n   */\n  getAPR = async (totalSupply, WBCHPrice, GOBPrice) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        WBCHPrice = Number(WBCHPrice);\n        GOBPrice = Number(GOBPrice);\n\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let rewardsToken = await contract.rewardsToken();\n        let getTokenData = await this.getTokenSymbolAndDecimal(rewardsToken);\n        let rewardRate = await contract.rewardRate();\n        rewardRate = rewardRate.toString() / 10 ** getTokenData.tokenDecimal;\n        rewardRate = toFixedCustm(rewardRate);\n\n        const secondsInAYear = 365 * 24 * 60 * 60;\n\n        const apr =\n          ((rewardRate * WBCHPrice * secondsInAYear) /\n            (totalSupply * GOBPrice)) *\n          100;\n\n        // console.log(apr, \"<===apr\")\n\n        resolve(apr > 1 ? Number(apr).toFixed(2) : Number(apr).toFixed(4));\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get NFT\n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} address APR in Success or Error in Fail\n   */\n  getNftPoolAddress = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const NftContract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let factoryAddress = await NftContract.factory();\n\n        let positions = await NftContract.positions(tokenId);\n        const facoryContract = this.getContract(\n          JSON.stringify(UniswapV3Factory),\n          factoryAddress,\n          true\n        );\n        const getPool = await facoryContract.getPool(\n          positions.token0,\n          positions.token1,\n          positions.fee\n        );\n        // console.log(apr, \"<===apr\")\n\n        resolve(getPool);\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Stake\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  unStakeFromMigration = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(MigrationStakingABI),\n          this.contractDetails.migrationAddress,\n          true\n        );\n        let tx = await contract.unstake(amount, true);\n        let receipt = await tx.wait();\n        resolve(receipt);\n        // resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * NFT Stake in Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  compoundPool = async (tokenId, walletAddress) => {\n    tokenId = tokenId.toString();\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        const approve = await contract.interface.encodeFunctionData(\"approve\", [\n          this.contractDetails.compoundAddress,\n          tokenId,\n        ]);\n        const safeTransferFrom = await contract.interface.encodeFunctionData(\n          \"safeTransferFrom\",\n          [\n            walletAddress,\n            this.contractDetails.compoundAddress,\n            tokenId,\n            \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000\",\n          ]\n        );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[approve, safeTransferFrom]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.nftManagerContractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in compoundPool\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n\n\n  changeRange = async (data, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getByteData = makeByteDataForV3(data);\n\n\n\n        const response = await contract.safeTransferFrom(\n          walletAddress,\n          this.contractDetails.contractAddress,\n          tokenId,\n          getByteData\n        );\n\n        let receipt = await response.wait();\n\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in changeRange\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n}\n\nexport default Web3Intraction;"],"names":["getCheckSumAddress","address","ethers","error","formatValue","value","Number","toFixed","toFixedCustm","x","e","Math","abs","parseInt","toString","split","pow","Array","join","substring","makeByteData","data","encode","makeByteDataForV3","toCommas","parts","replace","constructor","currentNetwork","provider","getContract","abi","isSigner","Contract","JSON","parse","this","SIGNER","PROVIDER","console","log","contractInstance","_provider","checkAllowance","async","tokenAmount","tokenAddress","approvalAddress","Promise","resolve","reject","tokenAmountWithDecimal","walletAddres","getAddress","tokenContract","stringify","TokenABI","getBalance","balanceOf","tokenDecimal","decimals","tokenAllowence","allowance","getTotalSupplyInEth","totalSupply","txn","approve","wait","setTimeout","code","reason","message","createIncentive","keys","rewards","minimumWidth","tx","contract","contractDetails","contractAddress","rewardTokenAmount","receipt","stake","tokenId","walletAddress","NFTManager","nftManagerContractAddress","getByteData","getSafeContract","inputs","internalType","name","type","outputs","stateMutability","ownerOf","interface","encodeFunctionData","safeTransferFrom","multicallData","to","response","sendTransaction","multiStakeWithMultiCall","stakeData","i","length","stakeToken","push","getDeposit","deposits","getStakes","incentiveId","stakes","liquidity","secondsPerLiquidityInsideInitialX128","getRewardInfo","getRewards","rewardToken","mutliCallReStake","unStakeToken","claimReward","mutliCallClaimAll","claimAllData","mutliCallUnstake","multicallMethod","secondsInsideX128","mutliCallUnstakeAll","unStakeData","unStake","unstakeToken","claimRewards","rewardsToken","withdrawToken","getTokenId","index","tokenOfOwnerByIndex","getTokenURI","tokenURI","endIncentive","tokenIds","encodeData","getTokenDecimal","decimal","symbol","tokenStake","amount","StakeABI","stakeContractAddress","getStakingContract","stakingToken","stakeAmount","tokenWithdraw","tokenData","withdraw","tokenExit","exit","getTokenRewards","getReward","getTokenBalance","balance","getTokenSymbolAndDecimal","getDetailInfo","bscInstance","bscSupply","chainId","bscDecimal","getRewardsContract","stakedAmount","earnedAmount","earned","_tokenTotalSupply","parseFloat","unStakedAmount","rewardSymbol","stakeSymbol","tokenTotalSupply","unStackTotalSupply","nftCount","id","incentives","getPoolDetails","poolAddress","PancakeV3Pool","getToken0Address","token0","getToken1Address","token1","getToken0Detail","getToken1Detail","token0Symbol","token1Symbol","getAPR","WBCHPrice","GOBPrice","getTokenData","rewardRate","apr","getNftPoolAddress","NftContract","factoryAddress","factory","positions","facoryContract","UniswapV3Factory","getPool","fee","unStakeFromMigration","MigrationStakingABI","migrationAddress","unstake","compoundPool","compoundAddress","changeRange","window","ethereum","getSigner","rpcUrl","UniswapV3Staker","walletType","label"],"sourceRoot":""}