{"version":3,"file":"static/js/9672.2849839f.chunk.js","mappings":"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","sources":["helpers/constants.js","helpers/utils.js","hooks/useWallet.js","utils/web3Intraction.js"],"sourcesContent":["import { ethers } from \"ethers\";\nimport computeABI from \"utils/ABI/computeABi.json\";\n\n//img\n\nimport Icon1 from \"assets/farmingAssets/icons/0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04.png\";\nimport Icon2 from \"assets/farmingAssets/icons/0x56381cB87C8990971f3e9d948939e1a95eA113a3.png\";\nimport Icon3 from \"assets/farmingAssets/icons/0xbb2A35cc3e3dDb679fe30A82051633bC822e4191.png\";\nimport Icon4 from \"assets/farmingAssets/icons/0xbb10B6D11db70f33417b08e0B87042275C933Bb9.png\";\nimport Icon5 from \"assets/farmingAssets/icons/0xbbb3700F33fCb64437Dc28A7Beb6b21f5cC76FB9.png\";\nimport Icon6 from \"assets/farmingAssets/icons/0xBc2F884680c95A02cea099dA2F524b366d9028Ba.png\";\nimport Icon7 from \"assets/farmingAssets/icons/0xBc9bD8DDe6C5a8e1CBE293356E02f5984693b195.png\";\n\n\nexport const cryptoData = [\n    {\n      label: \"SmartBCH\",\n      symbol: \"SmartBCH\",\n      name: \"SmartBCH\",\n      type: \"SmartBCH\",\n      chainName: \"Smart Bitcoin Cash\",\n      rpcUrls: [\n        \"https://rpc-sbch.goblins.cash/\",\n        \"https://smartbch.greyh.at\",\n        \"https://smartbch.greyh.at\",\n        \"https://smartbch.fountainhead.cash/mainnet\",\n        \"https://global.uat.cash\",\n        \"https://rpc.uatvo.com\",\n        \"https://api.tatum.io/v3/blockchain/node/bch-mainnet \",\n        \"https://rpc-mainnet.smartbch.org\",\n        \"https://smartbch.devops.cash/mainnet\",\n      ],\n      chainId: 10000,\n      rpcUrl: \"https://rpc-sbch.goblins.cash/\",\n      contractAddress: process.env.REACT_APP_BCH_STAKING_CONTRACT,\n      nftManagerContractAddress:\n        process.env.REACT_APP_BCH_NFT_MANAGER_CONTRACT,\n      stakeContractAddress: process.env.REACT_APP_BCH_TOKEN_STAKING_CONTRACT,\n      explorerLink: \"https://smartscout.cash/\",\n      rpcUrls: [\"https://smartbch.greyh.at\"],\n\n      blockExplorerUrls: [\"https://smartbch.org/\"],\n      nativeCurrency: { name: \"Bitcoin Cash\", symbol: \"BCH\", decimals: 18 },\n    },\n];\n\n\n\nexport const graphQLUrl = {\n  10000: \"https://graph.dfd.cash/subgraphs/name/v3stakerminwidths\",\n  56: \"https://api.studio.thegraph.com/query/78445/v3stakerminwidths/0.0.5\",\n  97: \"https://api.studio.thegraph.com/query/78445/v3stakerminwidths/0.0.5\",\n};\n\nexport const priceGraphQl =\n  \"https://graph.dfd.cash/subgraphs/name/goblins/subgraph-v3\";\n\nexport const supportedChainIds = [56, 97, 10000];\n\nexport const getUniqueToken = (data) => {\n  const uniqueTokenIds = new Set(data.map((item) => item.tokenId));\n  // Convert the Set back to an array of objects\n  const uniqueData = Array.from(uniqueTokenIds).map((tokenId) => ({ tokenId }));\n  return uniqueData;\n};\n\nexport const getProvider = async () => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const provider = await new ethers.getDefaultProvider(\n        \"https://bsc-testnet-rpc.publicnode.com\"\n      );\n\n  \n\n      resolve(provider);\n    } catch (err) {\n      console.log(err, \"<===err in getProvider\");\n      reject(err);\n    }\n  });\n};\n\nexport const getContract = async () => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const provider = await getProvider();\n      const contract = new ethers.Contract(\n        \"0xEA589fCCE1df1ee1ca5E1796A683408a36E6e267\",\n        computeABI,\n        provider\n      );\n      resolve(contract);\n    } catch (err) {\n      console.log(err, \"<===err in getContract\");\n      reject(err);\n    }\n  });\n};\n\nexport const makeComputeData = async (key) => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const contract = await getContract();\n\n      let compute = await contract.compute(key);\n      resolve(compute);\n    } catch (err) {\n      console.log(err, \"<===err in makeComputeData\");\n      reject(err);\n    }\n  });\n};\n\nexport const getSymbols = {\n  \"0x3743ec0673453e5009310c727ba4eaf7b3a1cc04\": Icon1,\n  \"0x56381cb87c8990971f3e9d948939e1a95ea113a3\": Icon2,\n  \"0xbb2a35cc3e3ddb679fe30a82051633bc822e4191\": Icon3,\n  \"0xbb10b6d11db70f33417b08e0b87042275c933bb9\": Icon4,\n  \"0xbbb3700f33fcb64437dc28a7beb6b21f5cc76fb9\": Icon5,\n  \"0xbc2f884680c95a02cea099da2f524b366d9028ba\": Icon6,\n  \"0xbc9bd8dde6c5a8e1cbe293356e02f5984693b195\": Icon7,\n};\n\nexport const getSortedData = (arr, sortKey, sortOrder) => {\n\n  console.log(arr, sortKey, sortOrder, \"<====arr, sortKey, sortOrder\")\n  if (!arr || !arr.length) {\n    return [];\n  } else {\n    const sortedArr = [...arr].sort((a, b) => {\n      let aValue = a.key[sortKey];\n      let bValue = b.key[sortKey];\n\n      if (sortKey === \"apr\" || sortKey === \"tvl\" || sortKey === \"nftCount\") {\n        aValue = parseFloat(a[sortKey]);\n        bValue = parseFloat(b[sortKey]);\n      }\n\n      if (sortOrder === \"asc\") {\n        return aValue > bValue ? 1 : -1;\n      } else {\n        return aValue < bValue ? 1 : -1;\n      }\n    });\n\n    return sortedArr;\n  }\n};\n\n","import { toast } from \"react-toastify\";\nimport { ethers } from \"ethers\";\nimport BigNumber from \"bignumber.js\";\n\nconst PRECISION = 4;\n\nexport function truncateWalletAddress(address, isNotWalletAddress) {\n  if (!address) return \"\";\n  if (!isNotWalletAddress) {\n    address = address.slice(0, 7) + \"...\" + address.slice(36);\n  } else {\n    address = address.slice(0, 8) + \"...\" + address.slice(55);\n  }\n\n  return address;\n}\n\nexport const copyClipBoard = (value) => {\n  if (!value) return toast.error(\"Something wrong!\");\n\n  let textarea = document.createElement(\"textarea\");\n  textarea.textContent = value;\n  textarea.style.position = \"fixed\"; // Prevent scrolling to bottom of page in Microsoft Edge.\n  document.body.appendChild(textarea);\n  textarea.select();\n  try {\n    document.execCommand(\"copy\"); // Security exception may be thrown by some browsers.\n  } catch (ex) {\n    console.warn(\"Copy to clipboard failed.\", ex);\n    // return prompt(\"Copy to clipboard: Ctrl+C, Enter\", text);\n  } finally {\n    document.body.removeChild(textarea);\n  }\n\n  toast.success(\"Copied!\");\n};\n\nexport const getCheckSumAddress = (address) => {\n  if (!address) return null;\n  try {\n    return ethers.utils.getAddress(address);\n  } catch (error) {\n    return null;\n  }\n};\n\nexport function validateTelegramLink(link) {\n  // Define a regular expression for a Telegram link\n  const telegramRegex = /^(https?:\\/\\/)?(www\\.)?t\\.me\\/[a-zA-Z0-9_]{5,32}\\/?$/;\n\n  // Test the link against the regular expression\n  const isValid = telegramRegex.test(link);\n\n  // Return the validation result\n  return isValid;\n}\n\nexport function isValidEmail(email) {\n  // Regular expression for basic email validation\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n  // Test the email against the regular expression\n  return emailRegex.test(email);\n}\n\nexport function getPercentage(partialValue, totalValue) {\n  return (100 * partialValue) / totalValue;\n}\n\nexport function getGrowthPercentage(initialValue, currentValue) {\n  initialValue = Number(initialValue);\n  currentValue = Number(currentValue);\n  return ((currentValue - initialValue) / initialValue) * 100;\n}\n\nexport const sumArrayValue = (arr, key) => {\n  const result = arr.reduce(function (acc, obj) {\n    return Number(acc) + Number(obj[key]);\n  }, 0);\n  return result || 0;\n};\n\nexport function formatValue(value) {\n  if (!value) return 0;\n  value = Number(value);\n  if (value < 1000) {\n    return Number(value).toFixed(2);\n  }\n  if (value >= 1000 && value < 100000) {\n    return ` ${(value / 1000).toFixed(2)}K`;\n  } else if (value >= 100000 && value < 1000000) {\n    return ` ${(value / 1000).toFixed(2)}K`;\n  } else if (value >= 1000000 && value <= 1000000000) {\n    return ` ${(value / 1000000).toFixed(2)}M`;\n  } else if (value >= 1000000000 && value < 1000000000000) {\n    return ` ${(value / 1000000000).toFixed(2)}B`;\n  } else {\n    return Number(value).toFixed(2);\n  }\n}\n\nexport function hexStringToNumber(hexString) {\n  return parseInt(hexString, 16);\n}\n\nexport const calculateBonus = (amount) => {\n  amount = Number(amount);\n  if (amount >= 100 && amount < 500) {\n    return 1; // 1%bonus\n  } else if (amount >= 500 && amount < 2000) {\n    return 2; //2% bonus\n  } else if (amount >= 2000 && amount < 10000) {\n    return 3; //3% bonus\n  } else if (amount >= 10000 && amount < 20000) {\n    return 5; //5% bonus\n  } else if (amount >= 20000) {\n    return 10; //10% bonus\n  } else {\n    return 0;\n  }\n};\n\nexport const convertWeiToEth = (value) => {\n  if (!value) return 0;\n\n  value = value.toString();\n\n  return Number(ethers.utils.formatEther(value));\n};\n\nexport function toFixed(a, b, precision) {\n  if (toBigNumber(a).isZero() || toBigNumber(b).isZero()) {\n    return \"0\";\n  }\n  return toBigNumber(a)\n    .div(toBigNumber(b))\n    .toFormat(precision ?? PRECISION);\n}\n\nexport function formatUnits(a, decimals, precision) {\n  if (!decimals) return \"\";\n  return toFixed(a, toBigNumber(10).pow(decimals), precision);\n}\n\nexport function toBigNumber(n) {\n  return new BigNumber(n.toString());\n}\n\nexport function toFixedCustm(x) {\n  if (Math.abs(x) < 1.0) {\n    var e = parseInt(x.toString().split(\"e-\")[1]);\n    if (e) {\n      x *= Math.pow(10, e - 1);\n      x = \"0.\" + new Array(e).join(\"0\") + x.toString().substring(2);\n    }\n  } else {\n    var e = parseInt(x.toString().split(\"+\")[1]);\n    if (e > 20) {\n      e -= 20;\n      x /= Math.pow(10, e);\n      x += new Array(e + 1).join(\"0\");\n    }\n  }\n  return x;\n}\nexport function truncateToFixed(value, decimalPlaces) {\n  const factor = Math.pow(10, decimalPlaces);\n  return Math.floor(value * factor) / factor;\n}\n\n\n\nexport const makeByteData = (data) => {\n\n  const incentiveKeyAbi =\n    \"tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)\";\n    let byteData = ethers.utils.defaultAbiCoder.encode([incentiveKeyAbi], [data])\n    return byteData\n};\n\n\nexport function toCommas(value) {\n  let parts = value.toString().split(\".\");\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  return parts.join(\".\");\n}\n","import { useEffect, useMemo, useState } from \"react\";\nimport { useWeb3React } from \"@web3-react/core\";\n\nimport { cryptoData } from \"helpers/constants\";\nimport { useDispatch } from \"react-redux\";\nimport { toast } from \"react-toastify\";\n\nimport { setCurrentNetwork } from \"state/dashboard/actions\";\n\n/**\n * Description:- Here we creating context provider for wallet where we managing all actions for wallet like:-connect, disconnect,switchNetwork, address, balance etc\n * @param {any} {children}\n * @returns {any}\n */\nexport const useWallet = () => {\n  const wallet = useWeb3React();\n  let dispatch = useDispatch();\n\n  // console.log(useWeb3ModalAccount, \"<====useWeb3ModalAccount\");\n\n  const [isActive, setIsActive] = useState(false);\n\n  const [address, setaddress] = useState(null);\n\n  const { account, provider, chainId } = wallet;\n\n  // console.log(providerHook, \"<====providerHook\")\n  useEffect(() => {\n    setIsActive(wallet?.isActive);\n    setaddress(account || \"\");\n  }, [account, wallet?.isActive]);\n\n  useEffect(() => {\n    if (provider && isActive) {\n      provider?.on(\"disconnect\", (res) => {\n        disconnect();\n        dispatch(setCurrentNetwork(null));\n      });\n    }\n  }, [provider, isActive]);\n\n  useEffect(() => {\n    try {\n      // toast.success(walletType);\n      if (chainId && isActive) {\n        let findChain = cryptoData.find(\n          (network) => network.chainId === chainId\n        );\n        if (findChain) {\n          dispatch(setCurrentNetwork(findChain));\n        } else {\n          dispatch(setCurrentNetwork(null));\n          toast.error(\n            \"This platform support only BNB, SmartBCH Please switch to that chain!\"\n          );\n        }\n      }\n    } catch (error) {}\n  }, [isActive, chainId]);\n\n  // console.log(state,accountHook, \"<====state\")\n\n  const values = useMemo(\n    () => ({\n      isActive,\n      address,\n\n      provider,\n      chainId,\n    }),\n\n    [isActive, address, chainId, provider]\n  );\n\n  return values;\n};\n","import { Contract, ethers } from \"ethers\";\n\n//ABI\nimport TokenABI from \"./ABI/TokenABI.json\";\nimport StakeABI from \"./ABI/StakeABI.json\";\nimport UniswapV3Staker from \"./ABI/UniswapV3Staker.json\";\nimport NFTManager from \"./ABI/NonfungiblePositionManager.json\";\nimport PancakeV3Pool from \"./ABI/PancakeV3Pool.json\";\nimport UniswapV3Factory from \"./ABI/UniswapV3Factory.json\";\n\nimport { makeByteData, toFixedCustm } from \"../helpers/utils\";\n\n\n\nclass Web3Intraction {\n  constructor(currentNetwork, provider) {\n\n\n    if (provider || window.ethereum) {\n      this.PROVIDER = provider;\n\n      this.SIGNER = this.PROVIDER.getSigner();\n    } else if (currentNetwork) {\n      this.PROVIDER = new ethers.providers.JsonRpcProvider(\n        currentNetwork?.rpcUrl\n      );\n\n      this.SIGNER = this.PROVIDER;\n    }\n\n    this.contractDetails = {\n      abi: UniswapV3Staker,\n      ...currentNetwork,\n    };\n    this.walletType = currentNetwork.label;\n  }\n\n  /**\n   * Get contract from abi and address\n   *\n   * @param {string} abi - ABI JSON\n   * @param {string} address - Contract Address\n   * @param {boolean} isSigner - signer ot not\n   *\n   * @returns {object} Contract\n   */\n  getContract = (abi, address, isSigner) => {\n    try {\n\n\n      let contract = new Contract(\n        address,\n        JSON.parse(abi),\n        isSigner ? this.SIGNER : this.PROVIDER\n      );\n\n      return contract;\n    } catch (error) {\n      console.log(\"error\", error);\n      return null;\n    }\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAmount number token amount\n   * @param {Number} tokenAddress token address\n\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  checkAllowance = async (tokenAmount, tokenAddress, approvalAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n\n        if (tokenAddress && approvalAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let getBalance = await tokenContract.balanceOf(walletAddres);\n          let tokenDecimal = await tokenContract.decimals();\n\n          getBalance = getBalance.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getBalance)) {\n            return reject(\"Don't have enough token\");\n          }\n\n          let tokenAllowence = await tokenContract.allowance(\n            walletAddres,\n            approvalAddress\n          );\n\n          let getTotalSupply = await tokenContract.totalSupply();\n          let getTotalSupplyInEth =\n            getTotalSupply.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getTotalSupplyInEth)) {\n            return reject(\"Don't have enough supply in pool\");\n          }\n\n          // tokenAmount = parseInt(tokenAmount);\n          tokenAllowence = tokenAllowence.toString();\n          let tokenAmountWithDecimal = 0;\n\n          if (tokenDecimal == 18) {\n            tokenAmountWithDecimal = ethers.utils.parseUnits(\n              tokenAmount.toString(),\n              \"ether\"\n            );\n          } else {\n            tokenAmountWithDecimal = Number(tokenAmount) * 10 ** tokenDecimal;\n          }\n\n          if (Number(tokenAmountWithDecimal) > tokenAllowence) {\n            const txn = await tokenContract.approve(\n              approvalAddress,\n              tokenAmountWithDecimal.toString()\n            );\n\n            await txn.wait();\n          }\n          resolve(tokenAmountWithDecimal);\n        }\n      } catch (error) {\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Create Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {number} rewards reward amount\n   * @param {number} minimumWidth Minimum Width value\n   * @param {address} tokenAddress Reward token address\n   * \n\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  createIncentive = async (keys, rewards, minimumWidth, tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx;\n\n        if (!tokenAddress) {\n          return reject(\"Token Address not found!\");\n        }\n\n\n\n        let rewardTokenAmount = await this.checkAllowance(\n          rewards,\n          tokenAddress,\n          this.contractDetails?.contractAddress\n        );\n\n\n        tx = await contract.createIncentive(\n          keys,\n          rewardTokenAmount.toString(),\n          minimumWidth\n        );\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in createIncentive\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * NFT Stake in Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n\n   * \n\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  stake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getByteData = makeByteData(keys);\n        let getSafeContract = await this.getContract(\n          JSON.stringify([\n            {\n              inputs: [\n                {\n                  internalType: \"address\",\n                  name: \"from\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"address\",\n                  name: \"to\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"uint256\",\n                  name: \"tokenId\",\n                  type: \"uint256\",\n                },\n                {\n                  internalType: \"bytes\",\n                  name: \"_data\",\n                  type: \"bytes\",\n                },\n              ],\n              name: \"safeTransferFrom\",\n              outputs: [],\n              stateMutability: \"nonpayable\",\n              type: \"function\",\n            },\n          ]),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getOwner = await contract.ownerOf(tokenId);\n        if (getOwner !== walletAddress) {\n          reject(\"You are not a NFT owner!\");\n          return;\n        }\n\n        // let stakeTxn = await getSafeContract.safeTransferFrom(\n        //   walletAddress,\n        //   this.contractDetails.contractAddress,\n        //   tokenId,\n        //   getByteData\n        // );\n\n        // Encode the function calls\n        const approve = await contract.interface.encodeFunctionData(\"approve\", [\n          this.contractDetails.contractAddress,\n          tokenId,\n        ]);\n        const safeTransferFrom =\n          await getSafeContract.interface.encodeFunctionData(\n            \"safeTransferFrom\",\n            [\n              walletAddress,\n              this.contractDetails.contractAddress,\n              tokenId,\n              getByteData,\n            ]\n          );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[approve, safeTransferFrom]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.nftManagerContractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for unstake and claim\n   * @param {array} keys [[reward token, pool address,start time, endTime, refundee address]]\n   * @param {string} tokenId token id\n   * @param {string} walletAddress Wallet Address\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  multiStakeWithMultiCall = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let stakeData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          let stakeToken = await contract.interface.encodeFunctionData(\n            \"stakeToken\",\n            [keys[i], tokenId]\n          );\n          stakeData.push(stakeToken);\n        }\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [stakeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Deposit in Incentive\n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDeposit = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let deposit = await contract.deposits(tokenId);\n\n        resolve(deposit);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get stakes in Incentive\n   *\n   * @param {string} tokenId token id\n   * @param {string} incentiveId incentive id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getStakes = async (tokenId, incentiveId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let stakes = await contract.stakes(tokenId, incentiveId);\n\n        resolve({\n          liquidity: stakes.liquidity.toString(),\n          secondsPerLiquidityInsideInitialX128:\n            stakes.secondsPerLiquidityInsideInitialX128.toString(),\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getStakes\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewardInfo = async (keys, tokenId) => {\n    try {\n      let contract = this.getContract(\n        JSON.stringify(this.contractDetails?.abi),\n        this.contractDetails?.contractAddress,\n        true\n      );\n      let rewards = await contract.getRewardInfo(keys, tokenId);\n      return rewards;\n    } catch (error) {\n      return null;\n    }\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} rewardToken rewardToken\n   * @param {string} walletAddress token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewards = async (rewardToken, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let rewards = await contract.rewards(rewardToken, walletAddress);\n\n        resolve(rewards);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for restake\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallReStake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        // Encode the function calls\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n        const stakeToken = await contract.interface.encodeFunctionData(\n          \"stakeToken\",\n          [keys, tokenId]\n        );\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[unStakeToken, stakeToken, claimReward]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for unstake and claim\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallUnstake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        // Encode the function calls\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[unStakeToken, claimReward]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///unstake\n\n  unStake = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.unstakeToken(keys, tokenId);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  claimRewards = async (rewardsToken, walletAddress) => {\n    console.log(rewardsToken, walletAddress, \"<===data\");\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.claimReward(rewardsToken, walletAddress, 0);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///withdraw\n\n  withdrawToken = async (tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.withdrawToken(tokenId, walletAddress, \"0x\");\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token Id\n   * @param {string} walletAddress own wallet address\n   * @param {string} index index\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenId = async (walletAddress, index) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenOfOwnerByIndex(\n          walletAddress,\n          index\n        );\n\n        resolve(response.toString());\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token URI\n   * @param {string} tokenId own wallet address\n   *\n   * @returns {Promise} base64 encoded in Success or Error in Fail\n   */\n  getTokenURI = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenURI(tokenId);\n\n        // console.log(response, \"<===response\")\n\n        resolve(response);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for endIncentive and unstake all staked nft.\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {array} tokenIds [token id]\n\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  endIncentive = async (keys, tokenIds) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let encodeData = [];\n\n        for (let i = 0; i < tokenIds.length; i++) {\n          let unstakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys, tokenIds[i]]\n          );\n          encodeData.push(unstakeToken);\n        }\n\n        let endIncentive = await contract.interface.encodeFunctionData(\n          \"endIncentive\",\n          [keys]\n        );\n\n        encodeData.push(endIncentive);\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [encodeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  getTokenDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (tokenAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let tokenDecimal = await tokenContract.decimals();\n          let tokenSymbol = await tokenContract.symbol();\n\n          resolve({\n            decimal: tokenDecimal,\n            symbol: tokenSymbol,\n          });\n        }\n      } catch (error) {\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Stake\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  tokenStake = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        let getStakingContract = await contract.stakingToken();\n\n        let stakeAmount = await this.checkAllowance(\n          amount,\n          getStakingContract,\n          this.contractDetails.stakeContractAddress\n        );\n\n        let tx = await contract.stake(stakeAmount);\n        let receipt = await tx.wait();\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Withdraw\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenWithdraw = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let getStakingContract = await contract.stakingToken();\n        let tokenData = await this.getTokenDecimal(getStakingContract);\n        let tokenAmountWithDecimal = Number(amount) * 10 ** tokenData.decimal;\n\n        // console.log(tokenAmountWithDecimal, \"<====tokenAmountWithDecimal\")\n        let tx = await contract.withdraw(tokenAmountWithDecimal.toString());\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Exit\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenExit = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let tx = await contract.exit();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenRewards = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        console.log(contract, \"<====contract\");\n        let tx = await contract.getReward();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenBalance = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n        let getBalance = await tokenContract.balanceOf(walletAddres);\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n        let getTotalSupply = await tokenContract.totalSupply();\n        let getTotalSupplyInEth =\n          getTotalSupply.toString() / 10 ** tokenDecimal;\n\n        resolve({\n          balance: getBalance.toString() / 10 ** tokenDecimal,\n          tokenDecimal: tokenDecimal,\n          symbol: symbol,\n          totalSupply: getTotalSupplyInEth,\n        });\n      } catch (error) {\n        console.log(error, \"<====err in getTokenBalance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenSymbolAndDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n\n        resolve({ tokenDecimal: tokenDecimal, symbol: symbol });\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Detail info\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDetailInfo = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n\n    \n        let walletAddress = this.SIGNER.getAddress();\n\n        let getStakingContract = await contract.stakingToken();\n        let getRewardsContract = await contract.rewardsToken();\n        let stakeToken = await this.getTokenBalance(getStakingContract);\n        let rewardToken = await this.getTokenSymbolAndDecimal(\n          getRewardsContract\n        );\n\n        let stakedAmount = await contract.balanceOf(walletAddress);\n        stakedAmount = stakedAmount.toString() / 10 ** stakeToken.tokenDecimal;\n\n        let earnedAmount = await contract.earned(walletAddress);\n        earnedAmount = earnedAmount.toString() / 10 ** rewardToken.tokenDecimal;\n\n        let totalSupply = await contract.totalSupply();\n        totalSupply = totalSupply.toString() / 10 ** stakeToken.tokenDecimal;\n\n        resolve({\n          balance: parseFloat(stakedAmount) + parseFloat(stakeToken.balance),\n          stakedAmount:\n            parseFloat(stakedAmount),\n          unStakedAmount:\n            parseFloat(stakeToken.balance) ,\n          totalSupply: parseInt(totalSupply),\n          earnedAmount: earnedAmount,\n          rewardSymbol: rewardToken.symbol,\n          stakeSymbol: stakeToken.symbol,\n          tokenTotalSupply: parseInt(stakeToken.totalSupply),\n          unStackTotalSupply:\n            parseInt(stakeToken.totalSupply) - parseInt(totalSupply),\n        });\n      } catch (error) {\n\n        console.log(error, \"<===error\")\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  nftCount = async (id) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let res = await contract.incentives(id);\n        resolve(res);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getPoolDetails = async (poolAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(PancakeV3Pool),\n          poolAddress,\n          true\n        );\n        let getToken0Address = await contract.token0();\n        let getToken1Address = await contract.token1();\n        let getToken0Detail = await this.getTokenSymbolAndDecimal(\n          getToken0Address\n        );\n        let getToken1Detail = await this.getTokenSymbolAndDecimal(\n          getToken1Address\n        );\n        resolve({\n          token0Symbol: getToken0Detail.symbol,\n          token1Symbol: getToken1Detail.symbol,\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getPoolSymbol\");\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get APR Rewards for staking\n   *\n   * @param {Number} totalSupply total stake amount\n   * @param {Number} WBCHPrice WBCH Price in USD\n   * @param {Number} GOBPrice GOB Price in USD\n   *\n   *\n   * @returns {Promise} Number APR in Success or Error in Fail\n   */\n  getAPR = async (totalSupply, WBCHPrice, GOBPrice) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        WBCHPrice = Number(WBCHPrice);\n        GOBPrice = Number(GOBPrice);\n\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let rewardsToken = await contract.rewardsToken();\n        let getTokenData = await this.getTokenSymbolAndDecimal(rewardsToken);\n        let rewardRate = await contract.rewardRate();\n        rewardRate = rewardRate.toString() / 10 ** getTokenData.tokenDecimal;\n        rewardRate = toFixedCustm(rewardRate);\n\n        const secondsInAYear = 365 * 24 * 60 * 60;\n\n        const apr =\n          ((rewardRate * WBCHPrice * secondsInAYear) /\n            (totalSupply * GOBPrice)) *\n          100;\n\n        // console.log(apr, \"<===apr\")\n\n        resolve(apr > 1 ? Number(apr).toFixed(2) : Number(apr).toFixed(4));\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get NFT \n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} address APR in Success or Error in Fail\n   */\n  getNftPoolAddress = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const NftContract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let factoryAddress = await NftContract.factory();\n\n        let positions = await NftContract.positions(tokenId);\n        const facoryContract = this.getContract(\n          JSON.stringify(UniswapV3Factory),\n          factoryAddress,\n          true\n        );\n        const getPool = await facoryContract.getPool(\n          positions.token0,\n          positions.token1,\n          positions.fee\n        );\n        // console.log(apr, \"<===apr\")\n\n        resolve(getPool);\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n}\n\nexport default Web3Intraction;\n"],"names":["cryptoData","label","symbol","name","type","chainName","rpcUrls","chainId","rpcUrl","contractAddress","process","nftManagerContractAddress","stakeContractAddress","explorerLink","blockExplorerUrls","nativeCurrency","decimals","priceGraphQl","getSymbols","Icon1","Icon2","getSortedData","arr","sortKey","sortOrder","console","log","length","sort","a","b","aValue","key","bValue","parseFloat","getCheckSumAddress","address","ethers","error","formatValue","value","Number","toFixed","toFixedCustm","x","e","Math","abs","parseInt","toString","split","pow","Array","join","substring","makeByteData","data","encode","toCommas","parts","replace","useWallet","wallet","useWeb3React","dispatch","useDispatch","isActive","setIsActive","useState","setaddress","account","provider","useEffect","on","res","disconnect","setCurrentNetwork","findChain","find","network","toast","useMemo","constructor","currentNetwork","getContract","abi","isSigner","Contract","JSON","parse","this","SIGNER","PROVIDER","checkAllowance","async","tokenAmount","tokenAddress","approvalAddress","Promise","resolve","reject","walletAddres","getAddress","tokenContract","stringify","TokenABI","getBalance","balanceOf","tokenDecimal","tokenAllowence","allowance","getTotalSupplyInEth","totalSupply","tokenAmountWithDecimal","txn","approve","wait","reason","message","createIncentive","keys","rewards","minimumWidth","tx","contract","contractDetails","rewardTokenAmount","code","stake","tokenId","walletAddress","NFTManager","getByteData","getSafeContract","inputs","internalType","outputs","stateMutability","ownerOf","interface","encodeFunctionData","safeTransferFrom","multicallData","to","response","sendTransaction","receipt","multiStakeWithMultiCall","stakeData","i","stakeToken","push","getDeposit","deposits","getStakes","incentiveId","stakes","liquidity","secondsPerLiquidityInsideInitialX128","getRewardInfo","getRewards","rewardToken","mutliCallReStake","unStakeToken","claimReward","mutliCallUnstake","unStake","unstakeToken","claimRewards","rewardsToken","withdrawToken","getTokenId","index","tokenOfOwnerByIndex","getTokenURI","tokenURI","endIncentive","tokenIds","encodeData","getTokenDecimal","decimal","tokenStake","amount","StakeABI","getStakingContract","stakingToken","stakeAmount","tokenWithdraw","tokenData","withdraw","tokenExit","exit","getTokenRewards","getReward","getTokenBalance","balance","getTokenSymbolAndDecimal","getDetailInfo","getRewardsContract","stakedAmount","earnedAmount","earned","unStakedAmount","rewardSymbol","stakeSymbol","tokenTotalSupply","unStackTotalSupply","nftCount","id","incentives","getPoolDetails","poolAddress","PancakeV3Pool","getToken0Address","token0","getToken1Address","token1","getToken0Detail","getToken1Detail","token0Symbol","token1Symbol","getAPR","WBCHPrice","GOBPrice","getTokenData","rewardRate","apr","getNftPoolAddress","NftContract","factoryAddress","factory","positions","facoryContract","UniswapV3Factory","getPool","fee","window","ethereum","getSigner","UniswapV3Staker","walletType"],"sourceRoot":""}