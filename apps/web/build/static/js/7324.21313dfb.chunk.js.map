{"version":3,"file":"static/js/7324.21313dfb.chunk.js","mappings":"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","sources":["utils/web3Intraction.js"],"sourcesContent":["import { Contract, ethers } from \"ethers\";\n\n//ABI\nimport MigrationStakingABI from \"./ABI/migrationStaking.json\";\nimport NFTManager from \"./ABI/NonfungiblePositionManager.json\";\nimport PancakeV3Pool from \"./ABI/PancakeV3Pool.json\";\nimport StakeABI from \"./ABI/StakeABI.json\";\nimport TokenABI from \"./ABI/TokenABI.json\";\nimport UniswapV3Factory from \"./ABI/UniswapV3Factory.json\";\nimport UniswapV3Staker from \"./ABI/UniswapV3Staker.json\";\n\nimport { makeByteData, makeByteDataForV3, toFixedCustm } from \"../helpers/utils\";\n\nclass Web3Intraction {\n  constructor(currentNetwork, provider) {\n    if (provider || window.ethereum) {\n\n      this.PROVIDER = provider;\n      this.SIGNER = this.PROVIDER.getSigner();\n    } else if (currentNetwork) {\n      this.PROVIDER = new ethers.providers.JsonRpcProvider(\n        currentNetwork?.rpcUrl\n      );\n      this.SIGNER = this.PROVIDER;\n    }\n    this.contractDetails = {\n      abi: UniswapV3Staker,\n      ...currentNetwork,\n    };\n    this.walletType = currentNetwork.label;\n    this.chainId = currentNetwork.chainId;\n  }\n\n  /**\n   * Get contract from abi and address\n   *\n   * @param {string} abi - ABI JSON\n   * @param {string} address - Contract Address\n   * @param {boolean} isSigner - signer ot not\n   *\n   * @returns {object} Contract\n   */\n\n  getContract = (abi, address, isSigner) => {\n    try {\n      let contract = new Contract(\n        address,\n        JSON.parse(abi),\n        isSigner ? this.SIGNER : this.PROVIDER\n      );\n\n      return contract;\n    } catch (error) {\n      console.log(\"error\", error);\n      return null;\n    }\n  };\n\n  contractInstance = (abi, address, _provider) => {\n    try {\n      let contract = new Contract(\n        address,\n        JSON.parse(abi),\n        new ethers.providers.JsonRpcProvider(_provider)\n      );\n\n      // let contract = new ethers.Contract(address, abi, new ethers.providers.JsonRpcProvider(_provider));\n\n      return contract;\n    } catch (error) {\n      console.log(\"error\", error);\n      return null;\n    }\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAmount number token amount\n   * @param {Number} tokenAddress token address\n\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  checkAllowance = async (tokenAmount, tokenAddress, approvalAddress) => {\n    return new Promise(async (resolve, reject) => {\n      let tokenAmountWithDecimal = 0;\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n        if (tokenAddress && approvalAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let getBalance = await tokenContract.balanceOf(walletAddres);\n          let tokenDecimal = await tokenContract.decimals();\n\n          getBalance = getBalance.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getBalance)) {\n            return reject(\"Don't have enough token\");\n          }\n\n          let tokenAllowence = await tokenContract.allowance(\n            walletAddres,\n            approvalAddress\n          );\n\n          let getTotalSupply = await tokenContract.totalSupply();\n          let getTotalSupplyInEth =\n            getTotalSupply.toString() / 10 ** tokenDecimal;\n          if (Number(tokenAmount) > Number(getTotalSupplyInEth)) {\n            return reject(\"Don't have enough supply in pool\");\n          }\n\n          // tokenAmount = parseInt(tokenAmount);\n          tokenAllowence = tokenAllowence.toString();\n\n          if (tokenDecimal == 18) {\n            tokenAmountWithDecimal = ethers.utils.parseUnits(\n              tokenAmount.toString(),\n              \"ether\"\n            );\n          } else {\n            tokenAmountWithDecimal = Number(tokenAmount) * 10 ** tokenDecimal;\n          }\n          tokenAmountWithDecimal = toFixedCustm(parseInt(tokenAmountWithDecimal));\n\n          if (Number(tokenAmountWithDecimal) > tokenAllowence) {\n            const txn = await tokenContract.approve(\n              approvalAddress,\n              tokenAmountWithDecimal.toString()\n            );\n            await txn.wait();\n          }\n          setTimeout(() => {\n            resolve(tokenAmountWithDecimal);\n          }, 5000)\n        }\n      } catch (error) {\n        if (error?.code === -32000) {\n          setTimeout(() => {\n            resolve(tokenAmountWithDecimal);\n          }, 5000)\n          return\n        }\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Create Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {number} rewards reward amount\n   * @param {number} minimumWidth Minimum Width value\n   * @param {address} tokenAddress Reward token address\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  createIncentive = async (keys, rewards, minimumWidth, tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx;\n        if (!tokenAddress) {\n          return reject(\"Token Address not found!\");\n        }\n        let rewardTokenAmount = await this.checkAllowance(\n          rewards,\n          tokenAddress,\n          this.contractDetails?.contractAddress\n        );\n\n        tx = await contract.createIncentive(\n          keys,\n          rewardTokenAmount.toString(),\n          minimumWidth\n        );\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in createIncentive\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * NFT Stake in Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  stake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getByteData = makeByteData(keys);\n        let getSafeContract = await this.getContract(\n          JSON.stringify([\n            {\n              inputs: [\n                {\n                  internalType: \"address\",\n                  name: \"from\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"address\",\n                  name: \"to\",\n                  type: \"address\",\n                },\n                {\n                  internalType: \"uint256\",\n                  name: \"tokenId\",\n                  type: \"uint256\",\n                },\n                {\n                  internalType: \"bytes\",\n                  name: \"_data\",\n                  type: \"bytes\",\n                },\n              ],\n              name: \"safeTransferFrom\",\n              outputs: [],\n              stateMutability: \"nonpayable\",\n              type: \"function\",\n            },\n          ]),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getOwner = await contract.ownerOf(tokenId);\n        if (getOwner !== walletAddress) {\n          reject(\"You are not a NFT owner!\");\n          return;\n        }\n\n\n        // Encode the function calls\n        const approve = await contract.interface.encodeFunctionData(\"approve\", [\n          this.contractDetails.contractAddress,\n          tokenId,\n        ]);\n        const safeTransferFrom =\n          await getSafeContract.interface.encodeFunctionData(\n            \"safeTransferFrom\",\n            [\n              walletAddress,\n              this.contractDetails.contractAddress,\n              tokenId,\n              getByteData,\n            ]\n          );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[approve, safeTransferFrom]]\n        );\n\n        const tx = {\n          to: this.contractDetails?.nftManagerContractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        console.log(receipt, \"<===receipt\");\n\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for unstake and claim\n   * @param {array} keys [[reward token, pool address,start time, endTime, refundee address]]\n   * @param {string} tokenId token id\n   * @param {string} walletAddress Wallet Address\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  multiStakeWithMultiCall = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let stakeData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          let stakeToken = await contract.interface.encodeFunctionData(\n            \"stakeToken\",\n            [keys[i], tokenId]\n          );\n          stakeData.push(stakeToken);\n        }\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [stakeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Deposit in Incentive\n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDeposit = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let deposit = await contract.deposits(tokenId);\n\n        resolve(deposit);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get stakes in Incentive\n   *\n   * @param {string} tokenId token id\n   * @param {string} incentiveId incentive id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getStakes = async (tokenId, incentiveId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let stakes = await contract.stakes(tokenId, incentiveId);\n\n        resolve({\n          liquidity: stakes.liquidity.toString(),\n          secondsPerLiquidityInsideInitialX128:\n            stakes.secondsPerLiquidityInsideInitialX128.toString(),\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getStakes\", incentiveId);\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewardInfo = async (keys, tokenId) => {\n    try {\n      let contract = this.getContract(\n        JSON.stringify(this.contractDetails?.abi),\n        this.contractDetails?.contractAddress,\n        true\n      );\n      let rewards = await contract.getRewardInfo(keys, tokenId);\n      return rewards;\n    } catch (error) {\n      return null;\n    }\n  };\n\n  /**\n   * Get Rewards in Incentive\n   * @param {array} rewardToken rewardToken\n   * @param {string} walletAddress token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getRewards = async (rewardToken, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let rewards = await contract.rewards(rewardToken, walletAddress);\n\n        resolve(rewards);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for restake\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallReStake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        // Encode the function calls\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n        const stakeToken = await contract.interface.encodeFunctionData(\n          \"stakeToken\",\n          [keys, tokenId]\n        );\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[unStakeToken, stakeToken, claimReward]]\n        );\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n        const response = await this.SIGNER.sendTransaction(tx);\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  /**\n * Mutli Call Function call for claim all  \n * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n * @param {string} tokenId token id\n *\n * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n */\n  mutliCallClaimAll = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n\n        let claimAllData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          const unStakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys[i], tokenId]\n          );\n          claimAllData.push(unStakeToken);\n\n          const stakeToken = await contract.interface.encodeFunctionData(\n            \"stakeToken\",\n            [keys[i], tokenId]\n          );\n          claimAllData.push(stakeToken);\n\n\n          const claimReward = await contract.interface.encodeFunctionData(\n            \"claimReward\",\n            [keys[i][0], walletAddress, 0]\n          );\n          claimAllData.push(claimReward);\n\n        }\n        // Encode the function calls\n\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [claimAllData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Mutli Call Function call for unstake and claim\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  mutliCallUnstake = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let getRewards = await contract.getRewardInfo(keys, tokenId);\n        // Encode the function calls\n        const claimReward = await contract.interface.encodeFunctionData(\n          \"claimReward\",\n          [keys[0], walletAddress, 0]\n        );\n        const unStakeToken = await contract.interface.encodeFunctionData(\n          \"unstakeToken\",\n          [keys, tokenId]\n        );\n        let multicallMethod = getRewards.secondsInsideX128.toString() > 0 ? [unStakeToken, claimReward] : [unStakeToken]\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [multicallMethod]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in mutliCallUnstake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  /**\n  * Mutli Call Function call for all unstake and claim \n  * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n  * @param {string} tokenId token id\n  *\n  * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n  */\n  mutliCallUnstakeAll = async (keys, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n\n        let unStakeData = [];\n\n        for (let i = 0; i < keys.length; i++) {\n          const unStakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys[i], tokenId]\n          );\n          unStakeData.push(unStakeToken);\n\n\n          let getRewards = await contract.getRewardInfo(keys[i], tokenId);\n\n          if (getRewards.secondsInsideX128.toString() > 0) {\n\n            const claimReward = await contract.interface.encodeFunctionData(\n              \"claimReward\",\n              [keys[i][0], walletAddress, 0]\n            );\n            unStakeData.push(claimReward);\n          }\n\n\n\n        }\n        // Encode the function calls\n\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [unStakeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///unstake\n\n  unStake = async (keys, tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.unstakeToken(keys, tokenId);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  claimRewards = async (rewardsToken, walletAddress) => {\n    console.log(rewardsToken, walletAddress, \"<===data\");\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.claimReward(rewardsToken, walletAddress, 0);\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  ///withdraw\n\n  withdrawToken = async (tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n\n        let tx = await contract.withdrawToken(tokenId, walletAddress, \"0x\");\n\n        let receipt = await tx.wait();\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token Id\n   * @param {string} walletAddress own wallet address\n   * @param {string} index index\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenId = async (walletAddress, index) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenOfOwnerByIndex(\n          walletAddress,\n          index\n        );\n\n        resolve(response.toString());\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  getTokenLiquidity = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.positions(tokenId);\n\n\n\n        resolve(response.liquidity.toString());\n      } catch (error) {\n        // console.log(error, \"<===error in getTokenId\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Nft Token URI\n   * @param {string} tokenId own wallet address\n   *\n   * @returns {Promise} base64 encoded in Success or Error in Fail\n   */\n  getTokenURI = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const response = await contract.tokenURI(tokenId);\n\n        // console.log(response, \"<===response\")\n\n        resolve(response);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Multi Call Function call for endIncentive and unstake all staked nft.\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   * @param {array} tokenIds [token id]\n\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  endIncentive = async (keys, tokenIds) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let encodeData = [];\n\n        for (let i = 0; i < tokenIds.length; i++) {\n          let unstakeToken = await contract.interface.encodeFunctionData(\n            \"unstakeToken\",\n            [keys, tokenIds[i]]\n          );\n          encodeData.push(unstakeToken);\n        }\n\n        let endIncentive = await contract.interface.encodeFunctionData(\n          \"endIncentive\",\n          [keys]\n        );\n\n        encodeData.push(endIncentive);\n\n        // Encode the function calls\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [encodeData]\n        );\n\n        const tx = {\n          to: this.contractDetails?.contractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        const response = await this.SIGNER.sendTransaction(tx);\n\n        let receipt = await response.wait(); // Wait for the transaction to be mined\n\n        resolve(receipt);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  getTokenDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (tokenAddress) {\n          let tokenContract = this.getContract(\n            JSON.stringify(TokenABI),\n            tokenAddress,\n            true\n          );\n\n          let tokenDecimal = await tokenContract.decimals();\n          let tokenSymbol = await tokenContract.symbol();\n\n          resolve({\n            decimal: tokenDecimal,\n            symbol: tokenSymbol,\n          });\n        }\n      } catch (error) {\n        console.log(error, \"<====err in allowance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Stake\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  tokenStake = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let getStakingContract = await contract.stakingToken();\n        let stakeAmount = await this.checkAllowance(\n          amount,\n          getStakingContract,\n          this.contractDetails.stakeContractAddress\n        );\n\n        let tx = await contract.stake(stakeAmount);\n        let receipt = await tx.wait();\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Withdraw\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenWithdraw = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let getStakingContract = await contract.stakingToken();\n        let tokenData = await this.getTokenDecimal(getStakingContract);\n        let tokenAmountWithDecimal = Number(amount) * 10 ** tokenData.decimal;\n\n        tokenAmountWithDecimal = parseInt(tokenAmountWithDecimal);\n\n        let tx = await contract.withdraw(tokenAmountWithDecimal.toString());\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in stake\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Exit\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  tokenExit = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let tx = await contract.exit();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Rewards\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getTokenRewards = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        let tx = await contract.getReward();\n        let receipt = await tx.wait();\n        resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenBalance = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let walletAddres = this.SIGNER.getAddress();\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n        let getBalance = await tokenContract.balanceOf(walletAddres);\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n        let getTotalSupply = await tokenContract.totalSupply();\n        let getTotalSupplyInEth =\n          getTotalSupply.toString() / 10 ** tokenDecimal;\n\n        resolve({\n          balance: getBalance.toString() / 10 ** tokenDecimal,\n          tokenDecimal: tokenDecimal,\n          symbol: symbol,\n          totalSupply: getTotalSupplyInEth,\n        });\n      } catch (error) {\n        console.log(error, \"<====err in getTokenBalance\");\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Check and Increase Allowance.\n   *\n   * @param {Number} tokenAddress ERC20 token address\n   *\n   *\n   * @returns {Promise} Promise\n   */\n  getTokenSymbolAndDecimal = async (tokenAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let tokenContract = this.getContract(\n          JSON.stringify(TokenABI),\n          tokenAddress,\n          true\n        );\n\n        let tokenDecimal = await tokenContract.decimals();\n        let symbol = await tokenContract.symbol();\n\n        resolve({ tokenDecimal: tokenDecimal, symbol: symbol });\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get Detail info\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getDetailInfo = async () => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n\n        let getStakingContract = await contract.stakingToken();\n        const bscInstance = this.contractInstance(\n          JSON.stringify(TokenABI),\n          \"0x701ACA29AE0F5d24555f1E8A6Cf007541291d110\",\n          \"https://bsc-dataseed.binance.org/\"\n        )\n\n        let bscSupply = 0\n        if (this.chainId == 10000) {\n          let bscDecimal = await bscInstance.decimals()\n          bscSupply = await bscInstance.totalSupply()\n          bscSupply = bscSupply.toString() / 10 ** bscDecimal;\n        }\n\n        let walletAddress = this.SIGNER.getAddress();\n\n\n\n\n        let getRewardsContract = await contract.rewardsToken();\n        let stakeToken = await this.getTokenBalance(getStakingContract);\n\n        let rewardToken = await this.getTokenSymbolAndDecimal(\n          getRewardsContract\n        );\n\n        let stakedAmount = await contract.balanceOf(walletAddress);\n        stakedAmount = stakedAmount.toString() / 10 ** stakeToken.tokenDecimal;\n\n        let earnedAmount = await contract.earned(walletAddress);\n        earnedAmount = earnedAmount.toString() / 10 ** rewardToken.tokenDecimal;\n\n        let totalSupply = await contract.totalSupply();\n\n        totalSupply = totalSupply.toString() / 10 ** stakeToken.tokenDecimal;\n\n        let _tokenTotalSupply = parseInt(stakeToken.totalSupply - bscSupply)\n        resolve({\n          balance: parseFloat(stakedAmount) + parseFloat(stakeToken.balance),\n          stakedAmount: parseFloat(stakedAmount),\n          unStakedAmount: parseFloat(stakeToken.balance),\n          totalSupply: parseInt(totalSupply),\n          earnedAmount: earnedAmount,\n          rewardSymbol: rewardToken.symbol,\n          stakeSymbol: stakeToken.symbol,\n          tokenTotalSupply: _tokenTotalSupply,\n          unStackTotalSupply:\n            parseInt(stakeToken.totalSupply) - parseInt(totalSupply),\n        });\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  nftCount = async (id) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(this.contractDetails?.abi),\n          this.contractDetails?.contractAddress,\n          true\n        );\n        let res = await contract.incentives(id);\n        resolve(res);\n      } catch (error) {\n        // console.log(error, \"<===error in buy\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  getPoolDetails = async (poolAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        let contract = this.getContract(\n          JSON.stringify(PancakeV3Pool),\n          poolAddress,\n          true\n        );\n        let getToken0Address = await contract.token0();\n        let getToken1Address = await contract.token1();\n        let getToken0Detail = await this.getTokenSymbolAndDecimal(\n          getToken0Address\n        );\n        let getToken1Detail = await this.getTokenSymbolAndDecimal(\n          getToken1Address\n        );\n        resolve({\n          token0Symbol: getToken0Detail.symbol,\n          token1Symbol: getToken1Detail.symbol,\n        });\n      } catch (error) {\n        console.log(error, \"<===error in getPoolSymbol\");\n\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get APR Rewards for staking\n   *\n   * @param {Number} totalSupply total stake amount\n   * @param {Number} WBCHPrice WBCH Price in USD\n   * @param {Number} GOBPrice GOB Price in USD\n   *\n   *\n   * @returns {Promise} Number APR in Success or Error in Fail\n   */\n  getAPR = async (totalSupply, WBCHPrice, GOBPrice) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        WBCHPrice = Number(WBCHPrice);\n        GOBPrice = Number(GOBPrice);\n\n        const contract = this.getContract(\n          JSON.stringify(StakeABI),\n          this.contractDetails.stakeContractAddress,\n          true\n        );\n        let rewardsToken = await contract.rewardsToken();\n        let getTokenData = await this.getTokenSymbolAndDecimal(rewardsToken);\n        let rewardRate = await contract.rewardRate();\n        rewardRate = rewardRate.toString() / 10 ** getTokenData.tokenDecimal;\n        rewardRate = toFixedCustm(rewardRate);\n\n        const secondsInAYear = 365 * 24 * 60 * 60;\n\n        const apr = \n          ((rewardRate * WBCHPrice * secondsInAYear) /\n            (totalSupply * GOBPrice)) *\n          100;\n\n        // console.log(apr, \"<===apr\")\n\n        resolve(apr > 1 ? Number(apr).toFixed(2) : Number(apr).toFixed(4));\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Get NFT\n   *\n   * @param {string} tokenId token id\n   *\n   * @returns {Promise} address APR in Success or Error in Fail\n   */\n  getNftPoolAddress = async (tokenId) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const NftContract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let factoryAddress = await NftContract.factory();\n\n        let positions = await NftContract.positions(tokenId);\n        const facoryContract = this.getContract(\n          JSON.stringify(UniswapV3Factory),\n          factoryAddress,\n          true\n        );\n        const getPool = await facoryContract.getPool(\n          positions.token0,\n          positions.token1,\n          positions.fee\n        );\n        // console.log(apr, \"<===apr\")\n\n        resolve(getPool);\n      } catch (error) {\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * Token Stake\n   *\n   * @param {string} amount amount value\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n\n  unStakeFromMigration = async (amount) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(MigrationStakingABI),\n          this.contractDetails.migrationAddress,\n          true\n        );\n        let tx = await contract.unstake(amount, true);\n        let receipt = await tx.wait();\n        resolve(receipt);\n        // resolve(receipt);\n      } catch (error) {\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n  /**\n   * NFT Stake in Incentive\n   *\n   * @param {array} keys [reward token, pool address,start time, endTime, refundee address]\n   *\n   *\n   * @returns {Promise} Object (Transaction Hash, Contract Address) in Success or Error in Fail\n   */\n  compoundPool = async (tokenId, walletAddress) => {\n    tokenId = tokenId.toString();\n    console.log(tokenId, \"tokenId\")\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n\n        const approve = await contract.interface.encodeFunctionData(\"approve\", [\n          this.contractDetails.compoundAddress,\n          tokenId,\n        ]);\n        const safeTransferFrom = await contract.interface.encodeFunctionData(\n          \"safeTransferFrom\",\n          [\n            walletAddress,\n            this.contractDetails.compoundAddress,\n            tokenId,\n            \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000\",\n          ]\n        );\n\n        const multicallData = contract.interface.encodeFunctionData(\n          \"multicall\",\n          [[approve, safeTransferFrom]]\n        );\n\n\n        const tx = {\n          to: this.contractDetails?.nftManagerContractAddress,\n          data: multicallData,\n          value: ethers.utils.parseEther(\"0\"), // Amount of Ether to send with the transaction\n        };\n\n        let response;\n        if (this.chainId == 8453) {\n          response = await this.SIGNER.sendTransaction({\n            ...tx,\n            gasLimit: ethers.utils.hexlify(5000000),\n          });\n        } else {\n          response = await this.SIGNER.sendTransaction(tx)\n        }\n\n        let receipt = await response.wait();\n        resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in compoundPool\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n        if (error?.code === -32000) {\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n\n\n  changeRange = async (data, tokenId, walletAddress) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const contract = this.getContract(\n          JSON.stringify(NFTManager),\n          this.contractDetails?.nftManagerContractAddress,\n          true\n        );\n        let getByteData = makeByteDataForV3(data);\n\n\n\n        const response = await contract.safeTransferFrom(\n          walletAddress,\n          this.contractDetails.contractAddress,\n          tokenId,\n          getByteData\n        );\n\n        let receipt = await response.wait();\n\n        resolve(receipt);\n        // let receipt = await stakeTxn.wait();\n        // resolve(receipt);\n      } catch (error) {\n        console.log(error, \"<===error in changeRange\");\n        if (error?.code === -32603) {\n          return reject(\"insufficient funds for intrinsic transaction cost\");\n        }\n\n        if (error?.code === -32000) {\n\n          setTimeout(() => {\n            resolve(true)\n          }, 5000)\n          return;\n        }\n        reject(error.reason || error.data?.message || error.message || error);\n      }\n    });\n  };\n}\n\nexport default Web3Intraction;"],"names":["constructor","currentNetwork","provider","getContract","abi","address","isSigner","Contract","JSON","parse","this","SIGNER","PROVIDER","error","console","log","contractInstance","_provider","ethers","checkAllowance","async","tokenAmount","tokenAddress","approvalAddress","Promise","resolve","reject","tokenAmountWithDecimal","walletAddres","getAddress","tokenContract","stringify","TokenABI","getBalance","balanceOf","tokenDecimal","decimals","toString","Number","tokenAllowence","allowance","getTotalSupplyInEth","totalSupply","toFixedCustm","parseInt","txn","approve","wait","setTimeout","code","reason","data","message","createIncentive","keys","rewards","minimumWidth","tx","contract","contractDetails","contractAddress","rewardTokenAmount","receipt","stake","tokenId","walletAddress","NFTManager","nftManagerContractAddress","getByteData","makeByteData","getSafeContract","inputs","internalType","name","type","outputs","stateMutability","ownerOf","interface","encodeFunctionData","safeTransferFrom","multicallData","to","value","response","sendTransaction","multiStakeWithMultiCall","stakeData","i","length","stakeToken","push","getDeposit","deposits","getStakes","incentiveId","stakes","liquidity","secondsPerLiquidityInsideInitialX128","getRewardInfo","getRewards","rewardToken","mutliCallReStake","unStakeToken","claimReward","mutliCallClaimAll","claimAllData","mutliCallUnstake","multicallMethod","secondsInsideX128","mutliCallUnstakeAll","unStakeData","unStake","unstakeToken","claimRewards","rewardsToken","withdrawToken","getTokenId","index","tokenOfOwnerByIndex","getTokenLiquidity","positions","getTokenURI","tokenURI","endIncentive","tokenIds","encodeData","getTokenDecimal","decimal","symbol","tokenStake","amount","StakeABI","stakeContractAddress","getStakingContract","stakingToken","stakeAmount","tokenWithdraw","tokenData","withdraw","tokenExit","exit","getTokenRewards","getReward","getTokenBalance","balance","getTokenSymbolAndDecimal","getDetailInfo","bscInstance","bscSupply","chainId","bscDecimal","getRewardsContract","stakedAmount","earnedAmount","earned","_tokenTotalSupply","parseFloat","unStakedAmount","rewardSymbol","stakeSymbol","tokenTotalSupply","unStackTotalSupply","nftCount","id","incentives","getPoolDetails","poolAddress","PancakeV3Pool","getToken0Address","token0","getToken1Address","token1","getToken0Detail","getToken1Detail","token0Symbol","token1Symbol","getAPR","WBCHPrice","GOBPrice","getTokenData","rewardRate","apr","toFixed","getNftPoolAddress","NftContract","factoryAddress","factory","facoryContract","UniswapV3Factory","getPool","fee","unStakeFromMigration","MigrationStakingABI","migrationAddress","unstake","compoundPool","compoundAddress","gasLimit","changeRange","makeByteDataForV3","window","ethereum","getSigner","rpcUrl","UniswapV3Staker","walletType","label"],"sourceRoot":""}